<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SVG to Filled Scratch Path Converter</title>
  <style>
    body { font-family: sans-serif; padding: 2em; background: #f4f4f4; }
    input, button { margin: 10px 0; padding: 8px; }
    #output { margin-top: 20px; white-space: pre-wrap; }
  </style>
</head>
<body>

<h2>SVG to Filled Scratch Path Converter</h2>
<input type="file" id="fileInput" accept=".svg" /><br />
<button onclick="processSVG()">Convert and Download</button>

<div id="output"></div>

<script>
const SCRATCH_WIDTH = 480;
const SCRATCH_HEIGHT = 360;
const CANVAS_WIDTH = 480;
const CANVAS_HEIGHT = 360;

function processSVG() {
  const fileInput = document.getElementById("fileInput");
  const file = fileInput.files[0];

  if (!file) {
    alert("Please select an SVG file.");
    return;
  }

  const reader = new FileReader();
  reader.onload = function (e) {
    // Create an image from the SVG text data
    const svgBlob = new Blob([e.target.result], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(svgBlob);
    const img = new Image();

    img.onload = function() {
      URL.revokeObjectURL(url);

      // Create offscreen canvas to rasterize SVG
      const canvas = document.createElement('canvas');
      canvas.width = CANVAS_WIDTH;
      canvas.height = CANVAS_HEIGHT;
      const ctx = canvas.getContext('2d');

      // Clear white background (important)
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Draw SVG image scaled to fit canvas exactly
      ctx.drawImage(img, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Scan canvas pixels and build continuous zigzag path through black/non-white pixels
      const pathPoints = scanCanvasForPath(ctx, CANVAS_WIDTH, CANVAS_HEIGHT);

      if (pathPoints.length === 0) {
        alert("No filled pixels found.");
        return;
      }

      // Normalize points to Scratch coords
      const [xList, yList] = normalizePoints(pathPoints);

      downloadList(xList, "X.txt");
      downloadList(yList, "Y.txt");

      document.getElementById("output").innerText = `Done! Points: ${xList.length}`;
    };

    img.onerror = function() {
      alert("Failed to load SVG image.");
    };

    img.src = url;
  };

  reader.readAsText(file);
}

// Scan canvas to generate continuous zigzag path over non-white pixels
function scanCanvasForPath(ctx, width, height) {
  const imgData = ctx.getImageData(0, 0, width, height);
  const data = imgData.data;

  let points = [];
  // Threshold for "non-white" pixel (alpha >0 and not white)
  function isFilledPixel(i) {
    const r = data[i];
    const g = data[i+1];
    const b = data[i+2];
    const a = data[i+3];
    // Consider pixel filled if not close to white and visible
    return a > 10 && !(r > 240 && g > 240 && b > 240);
  }

  // We'll do a horizontal zigzag scan:
  // For each y, scan x left->right if even row, right->left if odd row
  // Add points only for filled pixels, skipping white areas (no pen lifts!)

  for(let y = 0; y < height; y++) {
    const rowPoints = [];
    if (y % 2 === 0) {
      for(let x = 0; x < width; x++) {
        const idx = (y*width + x)*4;
        if(isFilledPixel(idx)) {
          rowPoints.push([x, y]);
        }
      }
    } else {
      for(let x = width -1; x >= 0; x--) {
        const idx = (y*width + x)*4;
        if(isFilledPixel(idx)) {
          rowPoints.push([x, y]);
        }
      }
    }

    if(rowPoints.length === 0) {
      // No filled pixels on this row, but we still must connect continuous path
      // So if last point exists, add a direct linear interpolation to next filled pixel in next row
      // (Or skip if next row also empty)
      continue; // Just skip empty rows (no pen lift allowed, but no points either)
    }

    // Add this row's points to main path
    points.push(...rowPoints);
  }

  return points;
}

// Scale and center points for Scratch coordinate system (-240 to 240, -180 to 180)
function normalizePoints(points) {
  let xs = points.map(p => p[0]);
  let ys = points.map(p => p[1]);

  let minX = Math.min(...xs), maxX = Math.max(...xs);
  let minY = Math.min(...ys), maxY = Math.max(...ys);

  let width = maxX - minX || 1;
  let height = maxY - minY || 1;

  let scale = Math.min(SCRATCH_WIDTH / width, SCRATCH_HEIGHT / height);

  let xList = [], yList = [];

  points.forEach(([x, y]) => {
    let xScaled = (x - minX - width / 2) * scale;
    let yScaled = (y - minY - height / 2) * scale;

    let xScratch = Math.max(-240, Math.min(240, xScaled));
    let yScratch = Math.max(-180, Math.min(180, -yScaled)); // invert Y axis

    xList.push(xScratch.toFixed(2));
    yList.push(yScratch.toFixed(2));
  });

  return [xList, yList];
}

// Download a list as a newline-separated text file
function downloadList(list, filename) {
  const blob = new Blob([list.join('\n')], { type: 'text/plain' });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
}
</script>

</body>
</html>
