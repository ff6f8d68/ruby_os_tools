<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SVG to Density-Varied Scratch Path</title>
  <style>
    body { font-family: sans-serif; padding: 2em; background: #f4f4f4; }
    input, button { margin: 10px 0; padding: 8px; }
    #output { margin-top: 20px; white-space: pre-wrap; }
  </style>
</head>
<body>

<h2>SVG to Density-Varied Scratch Path Converter</h2>
<input type="file" id="fileInput" accept=".svg" /><br />
<button onclick="processSVG()">Convert and Download</button>

<div id="output"></div>

<script>
const SCRATCH_WIDTH = 480;
const SCRATCH_HEIGHT = 360;
const CANVAS_WIDTH = 480;
const CANVAS_HEIGHT = 360;

// Row spacing range (in pixels). Smaller means denser lines.
const MIN_ROW_SPACING = 2;
const MAX_ROW_SPACING = 10;

function processSVG() {
  const fileInput = document.getElementById("fileInput");
  const file = fileInput.files[0];

  if (!file) {
    alert("Please select an SVG file.");
    return;
  }

  const reader = new FileReader();
  reader.onload = function (e) {
    // Create image from SVG text data
    const svgBlob = new Blob([e.target.result], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(svgBlob);
    const img = new Image();

    img.onload = function() {
      URL.revokeObjectURL(url);

      // Draw SVG on canvas
      const canvas = document.createElement('canvas');
      canvas.width = CANVAS_WIDTH;
      canvas.height = CANVAS_HEIGHT;
      const ctx = canvas.getContext('2d');

      // White background
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      ctx.drawImage(img, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Convert canvas to grayscale and threshold to BW
      const bwData = convertToBW(ctx, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Compute brightness profile for variable row spacing
      const brightnessProfile = computeBrightnessProfile(bwData, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Generate continuous zigzag path with density variation based on brightness
      const pathPoints = generateDensityVariedPath(bwData, brightnessProfile, CANVAS_WIDTH, CANVAS_HEIGHT);

      if (pathPoints.length === 0) {
        alert("No filled pixels found.");
        return;
      }

      const [xList, yList] = normalizePoints(pathPoints);

      downloadList(xList, "X.txt");
      downloadList(yList, "Y.txt");

      document.getElementById("output").innerText = `Done! Points: ${xList.length}`;
    };

    img.onerror = function() {
      alert("Failed to load SVG image.");
    };

    img.src = url;
  };

  reader.readAsText(file);
}

// Convert image to BW (black and white) using luminance threshold
function convertToBW(ctx, width, height) {
  const imgData = ctx.getImageData(0, 0, width, height);
  const data = imgData.data;

  for(let i = 0; i < data.length; i += 4) {
    // Calculate luminance (0=black, 255=white)
    const r = data[i], g = data[i+1], b = data[i+2];
    const lum = 0.299*r + 0.587*g + 0.114*b;
    // Threshold at 128 (middle gray)
    const bw = lum < 128 ? 0 : 255;
    data[i] = data[i+1] = data[i+2] = bw;
    data[i+3] = 255; // opaque
  }
  ctx.putImageData(imgData, 0, 0);
  return imgData;
}

// Compute average brightness per row for spacing calculation
function computeBrightnessProfile(imgData, width, height) {
  const data = imgData.data;
  let profile = new Array(height).fill(0);

  for(let y = 0; y < height; y++) {
    let sum = 0;
    for(let x = 0; x < width; x++) {
      const i = (y*width + x)*4;
      // brightness normalized 0 (black) to 1 (white)
      const bright = data[i] / 255;
      sum += bright;
    }
    profile[y] = sum / width; // average brightness of row
  }
  return profile;
}

// Generate a zigzag continuous path with row spacing varying by brightness
function generateDensityVariedPath(imgData, brightnessProfile, width, height) {
  const data = imgData.data;
  let points = [];

  // Map brightness to spacing: darker (brightness ~0) = min spacing, lighter ~1 = max spacing
  function brightnessToSpacing(brightness) {
    return MIN_ROW_SPACING + brightness * (MAX_ROW_SPACING - MIN_ROW_SPACING);
  }

  let y = 0;
  let lastX = null, lastY = null;

  while (y < height) {
    // Find nearest integer row
    const row = Math.floor(y);
    const spacing = brightnessToSpacing(brightnessProfile[row]);

    // Get filled pixels on this row in zig or zag order depending on row index
    let rowPoints = [];
    if (Math.floor(y / spacing) % 2 === 0) {
      for(let x = 0; x < width; x++) {
        const idx = (row*width + x)*4;
        if (data[idx] === 0) { // black pixel only
          rowPoints.push([x, row]);
        }
      }
    } else {
      for(let x = width -1; x >= 0; x--) {
        const idx = (row*width + x)*4;
        if (data[idx] === 0) {
          rowPoints.push([x, row]);
        }
      }
    }

    if (rowPoints.length === 0) {
      // No black pixels in this row: 
      // Optionally add interpolation point to connect to next filled point to avoid pen lift
      // For simplicity, skip empty rows for now
    } else {
      // Connect from last point to first point on this row by linear interpolation (to avoid pen lifts)
      if (lastX !== null && lastY !== null) {
        // Interpolate line between last point and first new point
        const [firstX, firstY] = rowPoints[0];
        const dist = Math.hypot(firstX - lastX, firstY - lastY);
        const steps = Math.floor(dist);
        for(let i=1; i<=steps; i++) {
          const interpX = lastX + (firstX - lastX) * i / steps;
          const interpY = lastY + (firstY - lastY) * i / steps;
          points.push([interpX, interpY]);
        }
      }
      points.push(...rowPoints);
      // Update last point
      const lastPt = rowPoints[rowPoints.length -1];
      lastX = lastPt[0];
      lastY = lastPt[1];
    }

    y += spacing;
  }

  return points;
}

// Scale and center points for Scratch coordinate system (-240 to 240, -180 to 180)
function normalizePoints(points) {
  let xs = points.map(p => p[0]);
  let ys = points.map(p => p[1]);

  let minX = Math.min(...xs), maxX = Math.max(...xs);
  let minY = Math.min(...ys), maxY = Math.max(...ys);

  let width = maxX - minX || 1;
  let height = maxY - minY || 1;

  let scale = Math.min(SCRATCH_WIDTH / width, SCRATCH_HEIGHT / height);

  let xList = [], yList = [];

  points.forEach(([x, y]) => {
    let xScaled = (x - minX - width / 2) * scale;
    let yScaled = (y - minY - height / 2) * scale;

    let xScratch = Math.max(-240, Math.min(240, xScaled));
    let yScratch = Math.max(-180, Math.min(180, -yScaled)); // invert Y axis

    xList.push(xScratch.toFixed(2));
    yList.push(yScratch.toFixed(2));
  });

  return [xList, yList];
}

// Download a list as newline-separated text file
function downloadList(list, filename) {
  const blob = new Blob([list.join('\n')], { type: 'text/plain' });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
}

</script>

</body>
</html>
